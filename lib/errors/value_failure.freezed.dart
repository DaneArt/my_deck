// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'value_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  InvalidEmail<T> invalidEmail<T>({@required T failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

  EmptyEmail<T> emptyEmail<T>({@required T failedValue}) {
    return EmptyEmail<T>(
      failedValue: failedValue,
    );
  }

  ShortUsername<T> shortUsername<T>({@required T failedValue}) {
    return ShortUsername<T>(
      failedValue: failedValue,
    );
  }

  EmptyUsername<T> emptyUsername<T>({@required T failedValue}) {
    return EmptyUsername<T>(
      failedValue: failedValue,
    );
  }

  ShortPassword<T> shortPassword<T>({@required T failedValue}) {
    return ShortPassword<T>(
      failedValue: failedValue,
    );
  }

  EmptyPassword<T> emptyPassword<T>({@required T failedValue}) {
    return EmptyPassword<T>(
      failedValue: failedValue,
    );
  }

  InvalidUniqueId<T> invalidUniqueId<T>({@required T failedValue}) {
    return InvalidUniqueId<T>(
      failedValue: failedValue,
    );
  }

  LongPassword<T> longPassword<T>({@required T failedValue}) {
    return LongPassword<T>(
      failedValue: failedValue,
    );
  }

  InvalidUsername<T> invalidUsername<T>({@required T failedValue}) {
    return InvalidUsername<T>(
      failedValue: failedValue,
    );
  }

  LongUsername<T> longUsername<T>({@required T failedValue}) {
    return LongUsername<T>(
      failedValue: failedValue,
    );
  }

  InvalidPassword<T> invalidPassword<T>({@required T failedValue}) {
    return InvalidPassword<T>(
      failedValue: failedValue,
    );
  }

  FileDoesNotExists<T> fileDoesNotExists<T>({@required T failedValue}) {
    return FileDoesNotExists<T>(
      failedValue: failedValue,
    );
  }

  ShortDeckTitle<T> shortDeckTitle<T>({@required T failedValue}) {
    return ShortDeckTitle<T>(
      failedValue: failedValue,
    );
  }

  InvalidDeckTitle<T> invalidDeckTitle<T>({@required T failedValue}) {
    return InvalidDeckTitle<T>(
      failedValue: failedValue,
    );
  }

  ExpiredToken<T> expiredToken<T>({@required T failedValue}) {
    return ExpiredToken<T>(
      failedValue: failedValue,
    );
  }

  WrongFileExtension<T> wrongFileExtension<T>({@required T failedValue}) {
    return WrongFileExtension<T>(
      failedValue: failedValue,
    );
  }

  LongDeckTitle<T> longDeckTitle<T>({@required T failedValue}) {
    return LongDeckTitle<T>(
      failedValue: failedValue,
    );
  }
}

// ignore: unused_element
const $ValueFailure = _$ValueFailureTearOff();

mixin _$ValueFailure<T> {
  T get failedValue;

  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  });

  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith;
}

abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

abstract class $InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidEmail<T> implements InvalidEmail<T> {
  _$InvalidEmail({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  factory InvalidEmail({@required T failedValue}) = _$InvalidEmail<T>;

  @override
  T get failedValue;
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith;
}

abstract class $EmptyEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $EmptyEmailCopyWith(
          EmptyEmail<T> value, $Res Function(EmptyEmail<T>) then) =
      _$EmptyEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$EmptyEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyEmailCopyWith<T, $Res> {
  _$EmptyEmailCopyWithImpl(
      EmptyEmail<T> _value, $Res Function(EmptyEmail<T>) _then)
      : super(_value, (v) => _then(v as EmptyEmail<T>));

  @override
  EmptyEmail<T> get _value => super._value as EmptyEmail<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(EmptyEmail<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$EmptyEmail<T> implements EmptyEmail<T> {
  _$EmptyEmail({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyEmail(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmptyEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $EmptyEmailCopyWith<T, EmptyEmail<T>> get copyWith =>
      _$EmptyEmailCopyWithImpl<T, EmptyEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return emptyEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptyEmail != null) {
      return emptyEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return emptyEmail(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptyEmail != null) {
      return emptyEmail(this);
    }
    return orElse();
  }
}

abstract class EmptyEmail<T> implements ValueFailure<T> {
  factory EmptyEmail({@required T failedValue}) = _$EmptyEmail<T>;

  @override
  T get failedValue;
  @override
  $EmptyEmailCopyWith<T, EmptyEmail<T>> get copyWith;
}

abstract class $ShortUsernameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortUsernameCopyWith(
          ShortUsername<T> value, $Res Function(ShortUsername<T>) then) =
      _$ShortUsernameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$ShortUsernameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortUsernameCopyWith<T, $Res> {
  _$ShortUsernameCopyWithImpl(
      ShortUsername<T> _value, $Res Function(ShortUsername<T>) _then)
      : super(_value, (v) => _then(v as ShortUsername<T>));

  @override
  ShortUsername<T> get _value => super._value as ShortUsername<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortUsername<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$ShortUsername<T> implements ShortUsername<T> {
  _$ShortUsername({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.shortUsername(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortUsername<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $ShortUsernameCopyWith<T, ShortUsername<T>> get copyWith =>
      _$ShortUsernameCopyWithImpl<T, ShortUsername<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return shortUsername(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortUsername != null) {
      return shortUsername(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return shortUsername(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortUsername != null) {
      return shortUsername(this);
    }
    return orElse();
  }
}

abstract class ShortUsername<T> implements ValueFailure<T> {
  factory ShortUsername({@required T failedValue}) = _$ShortUsername<T>;

  @override
  T get failedValue;
  @override
  $ShortUsernameCopyWith<T, ShortUsername<T>> get copyWith;
}

abstract class $EmptyUsernameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $EmptyUsernameCopyWith(
          EmptyUsername<T> value, $Res Function(EmptyUsername<T>) then) =
      _$EmptyUsernameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$EmptyUsernameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyUsernameCopyWith<T, $Res> {
  _$EmptyUsernameCopyWithImpl(
      EmptyUsername<T> _value, $Res Function(EmptyUsername<T>) _then)
      : super(_value, (v) => _then(v as EmptyUsername<T>));

  @override
  EmptyUsername<T> get _value => super._value as EmptyUsername<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(EmptyUsername<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$EmptyUsername<T> implements EmptyUsername<T> {
  _$EmptyUsername({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyUsername(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmptyUsername<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $EmptyUsernameCopyWith<T, EmptyUsername<T>> get copyWith =>
      _$EmptyUsernameCopyWithImpl<T, EmptyUsername<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return emptyUsername(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptyUsername != null) {
      return emptyUsername(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return emptyUsername(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptyUsername != null) {
      return emptyUsername(this);
    }
    return orElse();
  }
}

abstract class EmptyUsername<T> implements ValueFailure<T> {
  factory EmptyUsername({@required T failedValue}) = _$EmptyUsername<T>;

  @override
  T get failedValue;
  @override
  $EmptyUsernameCopyWith<T, EmptyUsername<T>> get copyWith;
}

abstract class $ShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortPasswordCopyWith(
          ShortPassword<T> value, $Res Function(ShortPassword<T>) then) =
      _$ShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortPasswordCopyWith<T, $Res> {
  _$ShortPasswordCopyWithImpl(
      ShortPassword<T> _value, $Res Function(ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as ShortPassword<T>));

  @override
  ShortPassword<T> get _value => super._value as ShortPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$ShortPassword<T> implements ShortPassword<T> {
  _$ShortPassword({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      _$ShortPasswordCopyWithImpl<T, ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  factory ShortPassword({@required T failedValue}) = _$ShortPassword<T>;

  @override
  T get failedValue;
  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith;
}

abstract class $EmptyPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $EmptyPasswordCopyWith(
          EmptyPassword<T> value, $Res Function(EmptyPassword<T>) then) =
      _$EmptyPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$EmptyPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyPasswordCopyWith<T, $Res> {
  _$EmptyPasswordCopyWithImpl(
      EmptyPassword<T> _value, $Res Function(EmptyPassword<T>) _then)
      : super(_value, (v) => _then(v as EmptyPassword<T>));

  @override
  EmptyPassword<T> get _value => super._value as EmptyPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(EmptyPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$EmptyPassword<T> implements EmptyPassword<T> {
  _$EmptyPassword({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyPassword(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmptyPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $EmptyPasswordCopyWith<T, EmptyPassword<T>> get copyWith =>
      _$EmptyPasswordCopyWithImpl<T, EmptyPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return emptyPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptyPassword != null) {
      return emptyPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return emptyPassword(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptyPassword != null) {
      return emptyPassword(this);
    }
    return orElse();
  }
}

abstract class EmptyPassword<T> implements ValueFailure<T> {
  factory EmptyPassword({@required T failedValue}) = _$EmptyPassword<T>;

  @override
  T get failedValue;
  @override
  $EmptyPasswordCopyWith<T, EmptyPassword<T>> get copyWith;
}

abstract class $InvalidUniqueIdCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidUniqueIdCopyWith(
          InvalidUniqueId<T> value, $Res Function(InvalidUniqueId<T>) then) =
      _$InvalidUniqueIdCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidUniqueIdCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUniqueIdCopyWith<T, $Res> {
  _$InvalidUniqueIdCopyWithImpl(
      InvalidUniqueId<T> _value, $Res Function(InvalidUniqueId<T>) _then)
      : super(_value, (v) => _then(v as InvalidUniqueId<T>));

  @override
  InvalidUniqueId<T> get _value => super._value as InvalidUniqueId<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidUniqueId<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidUniqueId<T> implements InvalidUniqueId<T> {
  _$InvalidUniqueId({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUniqueId(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidUniqueId<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidUniqueIdCopyWith<T, InvalidUniqueId<T>> get copyWith =>
      _$InvalidUniqueIdCopyWithImpl<T, InvalidUniqueId<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidUniqueId(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUniqueId != null) {
      return invalidUniqueId(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidUniqueId(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUniqueId != null) {
      return invalidUniqueId(this);
    }
    return orElse();
  }
}

abstract class InvalidUniqueId<T> implements ValueFailure<T> {
  factory InvalidUniqueId({@required T failedValue}) = _$InvalidUniqueId<T>;

  @override
  T get failedValue;
  @override
  $InvalidUniqueIdCopyWith<T, InvalidUniqueId<T>> get copyWith;
}

abstract class $LongPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $LongPasswordCopyWith(
          LongPassword<T> value, $Res Function(LongPassword<T>) then) =
      _$LongPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$LongPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $LongPasswordCopyWith<T, $Res> {
  _$LongPasswordCopyWithImpl(
      LongPassword<T> _value, $Res Function(LongPassword<T>) _then)
      : super(_value, (v) => _then(v as LongPassword<T>));

  @override
  LongPassword<T> get _value => super._value as LongPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(LongPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$LongPassword<T> implements LongPassword<T> {
  _$LongPassword({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.longPassword(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LongPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $LongPasswordCopyWith<T, LongPassword<T>> get copyWith =>
      _$LongPasswordCopyWithImpl<T, LongPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return longPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (longPassword != null) {
      return longPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return longPassword(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (longPassword != null) {
      return longPassword(this);
    }
    return orElse();
  }
}

abstract class LongPassword<T> implements ValueFailure<T> {
  factory LongPassword({@required T failedValue}) = _$LongPassword<T>;

  @override
  T get failedValue;
  @override
  $LongPasswordCopyWith<T, LongPassword<T>> get copyWith;
}

abstract class $InvalidUsernameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidUsernameCopyWith(
          InvalidUsername<T> value, $Res Function(InvalidUsername<T>) then) =
      _$InvalidUsernameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidUsernameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUsernameCopyWith<T, $Res> {
  _$InvalidUsernameCopyWithImpl(
      InvalidUsername<T> _value, $Res Function(InvalidUsername<T>) _then)
      : super(_value, (v) => _then(v as InvalidUsername<T>));

  @override
  InvalidUsername<T> get _value => super._value as InvalidUsername<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidUsername<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidUsername<T> implements InvalidUsername<T> {
  _$InvalidUsername({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUsername(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidUsername<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidUsernameCopyWith<T, InvalidUsername<T>> get copyWith =>
      _$InvalidUsernameCopyWithImpl<T, InvalidUsername<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidUsername(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUsername != null) {
      return invalidUsername(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidUsername(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUsername != null) {
      return invalidUsername(this);
    }
    return orElse();
  }
}

abstract class InvalidUsername<T> implements ValueFailure<T> {
  factory InvalidUsername({@required T failedValue}) = _$InvalidUsername<T>;

  @override
  T get failedValue;
  @override
  $InvalidUsernameCopyWith<T, InvalidUsername<T>> get copyWith;
}

abstract class $LongUsernameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $LongUsernameCopyWith(
          LongUsername<T> value, $Res Function(LongUsername<T>) then) =
      _$LongUsernameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$LongUsernameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $LongUsernameCopyWith<T, $Res> {
  _$LongUsernameCopyWithImpl(
      LongUsername<T> _value, $Res Function(LongUsername<T>) _then)
      : super(_value, (v) => _then(v as LongUsername<T>));

  @override
  LongUsername<T> get _value => super._value as LongUsername<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(LongUsername<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$LongUsername<T> implements LongUsername<T> {
  _$LongUsername({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.longUsername(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LongUsername<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $LongUsernameCopyWith<T, LongUsername<T>> get copyWith =>
      _$LongUsernameCopyWithImpl<T, LongUsername<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return longUsername(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (longUsername != null) {
      return longUsername(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return longUsername(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (longUsername != null) {
      return longUsername(this);
    }
    return orElse();
  }
}

abstract class LongUsername<T> implements ValueFailure<T> {
  factory LongUsername({@required T failedValue}) = _$LongUsername<T>;

  @override
  T get failedValue;
  @override
  $LongUsernameCopyWith<T, LongUsername<T>> get copyWith;
}

abstract class $InvalidPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidPasswordCopyWith(
          InvalidPassword<T> value, $Res Function(InvalidPassword<T>) then) =
      _$InvalidPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidPasswordCopyWith<T, $Res> {
  _$InvalidPasswordCopyWithImpl(
      InvalidPassword<T> _value, $Res Function(InvalidPassword<T>) _then)
      : super(_value, (v) => _then(v as InvalidPassword<T>));

  @override
  InvalidPassword<T> get _value => super._value as InvalidPassword<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidPassword<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidPassword<T> implements InvalidPassword<T> {
  _$InvalidPassword({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPassword(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidPasswordCopyWith<T, InvalidPassword<T>> get copyWith =>
      _$InvalidPasswordCopyWithImpl<T, InvalidPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPassword != null) {
      return invalidPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidPassword(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPassword != null) {
      return invalidPassword(this);
    }
    return orElse();
  }
}

abstract class InvalidPassword<T> implements ValueFailure<T> {
  factory InvalidPassword({@required T failedValue}) = _$InvalidPassword<T>;

  @override
  T get failedValue;
  @override
  $InvalidPasswordCopyWith<T, InvalidPassword<T>> get copyWith;
}

abstract class $FileDoesNotExistsCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $FileDoesNotExistsCopyWith(FileDoesNotExists<T> value,
          $Res Function(FileDoesNotExists<T>) then) =
      _$FileDoesNotExistsCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$FileDoesNotExistsCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $FileDoesNotExistsCopyWith<T, $Res> {
  _$FileDoesNotExistsCopyWithImpl(
      FileDoesNotExists<T> _value, $Res Function(FileDoesNotExists<T>) _then)
      : super(_value, (v) => _then(v as FileDoesNotExists<T>));

  @override
  FileDoesNotExists<T> get _value => super._value as FileDoesNotExists<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(FileDoesNotExists<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$FileDoesNotExists<T> implements FileDoesNotExists<T> {
  _$FileDoesNotExists({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.fileDoesNotExists(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileDoesNotExists<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $FileDoesNotExistsCopyWith<T, FileDoesNotExists<T>> get copyWith =>
      _$FileDoesNotExistsCopyWithImpl<T, FileDoesNotExists<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return fileDoesNotExists(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fileDoesNotExists != null) {
      return fileDoesNotExists(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return fileDoesNotExists(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fileDoesNotExists != null) {
      return fileDoesNotExists(this);
    }
    return orElse();
  }
}

abstract class FileDoesNotExists<T> implements ValueFailure<T> {
  factory FileDoesNotExists({@required T failedValue}) = _$FileDoesNotExists<T>;

  @override
  T get failedValue;
  @override
  $FileDoesNotExistsCopyWith<T, FileDoesNotExists<T>> get copyWith;
}

abstract class $ShortDeckTitleCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortDeckTitleCopyWith(
          ShortDeckTitle<T> value, $Res Function(ShortDeckTitle<T>) then) =
      _$ShortDeckTitleCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$ShortDeckTitleCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortDeckTitleCopyWith<T, $Res> {
  _$ShortDeckTitleCopyWithImpl(
      ShortDeckTitle<T> _value, $Res Function(ShortDeckTitle<T>) _then)
      : super(_value, (v) => _then(v as ShortDeckTitle<T>));

  @override
  ShortDeckTitle<T> get _value => super._value as ShortDeckTitle<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortDeckTitle<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$ShortDeckTitle<T> implements ShortDeckTitle<T> {
  _$ShortDeckTitle({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.shortDeckTitle(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortDeckTitle<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $ShortDeckTitleCopyWith<T, ShortDeckTitle<T>> get copyWith =>
      _$ShortDeckTitleCopyWithImpl<T, ShortDeckTitle<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return shortDeckTitle(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortDeckTitle != null) {
      return shortDeckTitle(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return shortDeckTitle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortDeckTitle != null) {
      return shortDeckTitle(this);
    }
    return orElse();
  }
}

abstract class ShortDeckTitle<T> implements ValueFailure<T> {
  factory ShortDeckTitle({@required T failedValue}) = _$ShortDeckTitle<T>;

  @override
  T get failedValue;
  @override
  $ShortDeckTitleCopyWith<T, ShortDeckTitle<T>> get copyWith;
}

abstract class $InvalidDeckTitleCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidDeckTitleCopyWith(
          InvalidDeckTitle<T> value, $Res Function(InvalidDeckTitle<T>) then) =
      _$InvalidDeckTitleCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidDeckTitleCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDeckTitleCopyWith<T, $Res> {
  _$InvalidDeckTitleCopyWithImpl(
      InvalidDeckTitle<T> _value, $Res Function(InvalidDeckTitle<T>) _then)
      : super(_value, (v) => _then(v as InvalidDeckTitle<T>));

  @override
  InvalidDeckTitle<T> get _value => super._value as InvalidDeckTitle<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDeckTitle<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidDeckTitle<T> implements InvalidDeckTitle<T> {
  _$InvalidDeckTitle({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDeckTitle(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDeckTitle<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDeckTitleCopyWith<T, InvalidDeckTitle<T>> get copyWith =>
      _$InvalidDeckTitleCopyWithImpl<T, InvalidDeckTitle<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidDeckTitle(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDeckTitle != null) {
      return invalidDeckTitle(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return invalidDeckTitle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDeckTitle != null) {
      return invalidDeckTitle(this);
    }
    return orElse();
  }
}

abstract class InvalidDeckTitle<T> implements ValueFailure<T> {
  factory InvalidDeckTitle({@required T failedValue}) = _$InvalidDeckTitle<T>;

  @override
  T get failedValue;
  @override
  $InvalidDeckTitleCopyWith<T, InvalidDeckTitle<T>> get copyWith;
}

abstract class $ExpiredTokenCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ExpiredTokenCopyWith(
          ExpiredToken<T> value, $Res Function(ExpiredToken<T>) then) =
      _$ExpiredTokenCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$ExpiredTokenCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ExpiredTokenCopyWith<T, $Res> {
  _$ExpiredTokenCopyWithImpl(
      ExpiredToken<T> _value, $Res Function(ExpiredToken<T>) _then)
      : super(_value, (v) => _then(v as ExpiredToken<T>));

  @override
  ExpiredToken<T> get _value => super._value as ExpiredToken<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ExpiredToken<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$ExpiredToken<T> implements ExpiredToken<T> {
  _$ExpiredToken({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.expiredToken(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExpiredToken<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $ExpiredTokenCopyWith<T, ExpiredToken<T>> get copyWith =>
      _$ExpiredTokenCopyWithImpl<T, ExpiredToken<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return expiredToken(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (expiredToken != null) {
      return expiredToken(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return expiredToken(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (expiredToken != null) {
      return expiredToken(this);
    }
    return orElse();
  }
}

abstract class ExpiredToken<T> implements ValueFailure<T> {
  factory ExpiredToken({@required T failedValue}) = _$ExpiredToken<T>;

  @override
  T get failedValue;
  @override
  $ExpiredTokenCopyWith<T, ExpiredToken<T>> get copyWith;
}

abstract class $WrongFileExtensionCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $WrongFileExtensionCopyWith(WrongFileExtension<T> value,
          $Res Function(WrongFileExtension<T>) then) =
      _$WrongFileExtensionCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$WrongFileExtensionCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $WrongFileExtensionCopyWith<T, $Res> {
  _$WrongFileExtensionCopyWithImpl(
      WrongFileExtension<T> _value, $Res Function(WrongFileExtension<T>) _then)
      : super(_value, (v) => _then(v as WrongFileExtension<T>));

  @override
  WrongFileExtension<T> get _value => super._value as WrongFileExtension<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(WrongFileExtension<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$WrongFileExtension<T> implements WrongFileExtension<T> {
  _$WrongFileExtension({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.wrongFileExtension(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WrongFileExtension<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $WrongFileExtensionCopyWith<T, WrongFileExtension<T>> get copyWith =>
      _$WrongFileExtensionCopyWithImpl<T, WrongFileExtension<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return wrongFileExtension(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (wrongFileExtension != null) {
      return wrongFileExtension(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return wrongFileExtension(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (wrongFileExtension != null) {
      return wrongFileExtension(this);
    }
    return orElse();
  }
}

abstract class WrongFileExtension<T> implements ValueFailure<T> {
  factory WrongFileExtension({@required T failedValue}) =
      _$WrongFileExtension<T>;

  @override
  T get failedValue;
  @override
  $WrongFileExtensionCopyWith<T, WrongFileExtension<T>> get copyWith;
}

abstract class $LongDeckTitleCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $LongDeckTitleCopyWith(
          LongDeckTitle<T> value, $Res Function(LongDeckTitle<T>) then) =
      _$LongDeckTitleCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$LongDeckTitleCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $LongDeckTitleCopyWith<T, $Res> {
  _$LongDeckTitleCopyWithImpl(
      LongDeckTitle<T> _value, $Res Function(LongDeckTitle<T>) _then)
      : super(_value, (v) => _then(v as LongDeckTitle<T>));

  @override
  LongDeckTitle<T> get _value => super._value as LongDeckTitle<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(LongDeckTitle<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$LongDeckTitle<T> implements LongDeckTitle<T> {
  _$LongDeckTitle({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  bool _didmessage = false;
  String _message;

  @override
  String get message {
    if (_didmessage == false) {
      _didmessage = true;
      _message = this.map(
        invalidEmail: (value) => S.current.error_value_email_incorrect,
        shortPassword: (value) => S.current.error_value_short_passwor,
        invalidUsername: (value) => S.current.error_value_invalid_login,
        longUsername: (value) => S.current.error_value_long_login,
        invalidPassword: (value) => S.current.error_value_invalid_password,
        longPassword: (value) => S.current.error_value_long_password,
        fileDoesNotExists: (value) => S.current.error_value_file_inexists,
        invalidDeckTitle: (value) => S.current.error_value_invalid_title,
        shortDeckTitle: (value) => S.current.error_value_title_short,
        expiredToken: (value) => S.current.error_auth_invalid_session,
        invalidUniqueId: (value) => S.current.error_auth_invalid_session,
        wrongFileExtension: (value) => S.current.error_value_file_inexists,
        longDeckTitle: (value) =>
            'Deck title should be shorter than 30 characters',
        shortUsername: (value) => 'Username must be longer than 4 characters',
        emptyPassword: (value) => 'Password is required',
        emptyEmail: (value) => 'Email is required',
        emptyUsername: (value) => 'Username is required',
      );
    }
    return _message;
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.longDeckTitle(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LongDeckTitle<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $LongDeckTitleCopyWith<T, LongDeckTitle<T>> get copyWith =>
      _$LongDeckTitleCopyWithImpl<T, LongDeckTitle<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidEmail(T failedValue),
    @required Result emptyEmail(T failedValue),
    @required Result shortUsername(T failedValue),
    @required Result emptyUsername(T failedValue),
    @required Result shortPassword(T failedValue),
    @required Result emptyPassword(T failedValue),
    @required Result invalidUniqueId(T failedValue),
    @required Result longPassword(T failedValue),
    @required Result invalidUsername(T failedValue),
    @required Result longUsername(T failedValue),
    @required Result invalidPassword(T failedValue),
    @required Result fileDoesNotExists(T failedValue),
    @required Result shortDeckTitle(T failedValue),
    @required Result invalidDeckTitle(T failedValue),
    @required Result expiredToken(T failedValue),
    @required Result wrongFileExtension(T failedValue),
    @required Result longDeckTitle(T failedValue),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return longDeckTitle(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidEmail(T failedValue),
    Result emptyEmail(T failedValue),
    Result shortUsername(T failedValue),
    Result emptyUsername(T failedValue),
    Result shortPassword(T failedValue),
    Result emptyPassword(T failedValue),
    Result invalidUniqueId(T failedValue),
    Result longPassword(T failedValue),
    Result invalidUsername(T failedValue),
    Result longUsername(T failedValue),
    Result invalidPassword(T failedValue),
    Result fileDoesNotExists(T failedValue),
    Result shortDeckTitle(T failedValue),
    Result invalidDeckTitle(T failedValue),
    Result expiredToken(T failedValue),
    Result wrongFileExtension(T failedValue),
    Result longDeckTitle(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (longDeckTitle != null) {
      return longDeckTitle(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result emptyEmail(EmptyEmail<T> value),
    @required Result shortUsername(ShortUsername<T> value),
    @required Result emptyUsername(EmptyUsername<T> value),
    @required Result shortPassword(ShortPassword<T> value),
    @required Result emptyPassword(EmptyPassword<T> value),
    @required Result invalidUniqueId(InvalidUniqueId<T> value),
    @required Result longPassword(LongPassword<T> value),
    @required Result invalidUsername(InvalidUsername<T> value),
    @required Result longUsername(LongUsername<T> value),
    @required Result invalidPassword(InvalidPassword<T> value),
    @required Result fileDoesNotExists(FileDoesNotExists<T> value),
    @required Result shortDeckTitle(ShortDeckTitle<T> value),
    @required Result invalidDeckTitle(InvalidDeckTitle<T> value),
    @required Result expiredToken(ExpiredToken<T> value),
    @required Result wrongFileExtension(WrongFileExtension<T> value),
    @required Result longDeckTitle(LongDeckTitle<T> value),
  }) {
    assert(invalidEmail != null);
    assert(emptyEmail != null);
    assert(shortUsername != null);
    assert(emptyUsername != null);
    assert(shortPassword != null);
    assert(emptyPassword != null);
    assert(invalidUniqueId != null);
    assert(longPassword != null);
    assert(invalidUsername != null);
    assert(longUsername != null);
    assert(invalidPassword != null);
    assert(fileDoesNotExists != null);
    assert(shortDeckTitle != null);
    assert(invalidDeckTitle != null);
    assert(expiredToken != null);
    assert(wrongFileExtension != null);
    assert(longDeckTitle != null);
    return longDeckTitle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidEmail(InvalidEmail<T> value),
    Result emptyEmail(EmptyEmail<T> value),
    Result shortUsername(ShortUsername<T> value),
    Result emptyUsername(EmptyUsername<T> value),
    Result shortPassword(ShortPassword<T> value),
    Result emptyPassword(EmptyPassword<T> value),
    Result invalidUniqueId(InvalidUniqueId<T> value),
    Result longPassword(LongPassword<T> value),
    Result invalidUsername(InvalidUsername<T> value),
    Result longUsername(LongUsername<T> value),
    Result invalidPassword(InvalidPassword<T> value),
    Result fileDoesNotExists(FileDoesNotExists<T> value),
    Result shortDeckTitle(ShortDeckTitle<T> value),
    Result invalidDeckTitle(InvalidDeckTitle<T> value),
    Result expiredToken(ExpiredToken<T> value),
    Result wrongFileExtension(WrongFileExtension<T> value),
    Result longDeckTitle(LongDeckTitle<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (longDeckTitle != null) {
      return longDeckTitle(this);
    }
    return orElse();
  }
}

abstract class LongDeckTitle<T> implements ValueFailure<T> {
  factory LongDeckTitle({@required T failedValue}) = _$LongDeckTitle<T>;

  @override
  T get failedValue;
  @override
  $LongDeckTitleCopyWith<T, LongDeckTitle<T>> get copyWith;
}
