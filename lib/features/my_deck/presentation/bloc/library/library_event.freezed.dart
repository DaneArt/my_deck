// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'library_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$LibraryEventTearOff {
  const _$LibraryEventTearOff();

  GetAllUsersDecks getAllUsersDecks() {
    return GetAllUsersDecks();
  }

  TryToStartTrain tryToStartTrain() {
    return TryToStartTrain();
  }

  AddDeck addDeck({@required Deck deck}) {
    return AddDeck(
      deck: deck,
    );
  }

  UpdateDeck updateDeck({@required Deck deck}) {
    return UpdateDeck(
      deck: deck,
    );
  }

  DeleteDeck deleteDeck({@required Deck deck}) {
    return DeleteDeck(
      deck: deck,
    );
  }

  TrainStarted trainStarted() {
    return TrainStarted();
  }
}

// ignore: unused_element
const $LibraryEvent = _$LibraryEventTearOff();

mixin _$LibraryEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    @required Result orElse(),
  });
}

abstract class $LibraryEventCopyWith<$Res> {
  factory $LibraryEventCopyWith(
          LibraryEvent value, $Res Function(LibraryEvent) then) =
      _$LibraryEventCopyWithImpl<$Res>;
}

class _$LibraryEventCopyWithImpl<$Res> implements $LibraryEventCopyWith<$Res> {
  _$LibraryEventCopyWithImpl(this._value, this._then);

  final LibraryEvent _value;
  // ignore: unused_field
  final $Res Function(LibraryEvent) _then;
}

abstract class $GetAllUsersDecksCopyWith<$Res> {
  factory $GetAllUsersDecksCopyWith(
          GetAllUsersDecks value, $Res Function(GetAllUsersDecks) then) =
      _$GetAllUsersDecksCopyWithImpl<$Res>;
}

class _$GetAllUsersDecksCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res>
    implements $GetAllUsersDecksCopyWith<$Res> {
  _$GetAllUsersDecksCopyWithImpl(
      GetAllUsersDecks _value, $Res Function(GetAllUsersDecks) _then)
      : super(_value, (v) => _then(v as GetAllUsersDecks));

  @override
  GetAllUsersDecks get _value => super._value as GetAllUsersDecks;
}

class _$GetAllUsersDecks implements GetAllUsersDecks {
  _$GetAllUsersDecks();

  @override
  String toString() {
    return 'LibraryEvent.getAllUsersDecks()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is GetAllUsersDecks);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return getAllUsersDecks();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getAllUsersDecks != null) {
      return getAllUsersDecks();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return getAllUsersDecks(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getAllUsersDecks != null) {
      return getAllUsersDecks(this);
    }
    return orElse();
  }
}

abstract class GetAllUsersDecks implements LibraryEvent {
  factory GetAllUsersDecks() = _$GetAllUsersDecks;
}

abstract class $TryToStartTrainCopyWith<$Res> {
  factory $TryToStartTrainCopyWith(
          TryToStartTrain value, $Res Function(TryToStartTrain) then) =
      _$TryToStartTrainCopyWithImpl<$Res>;
}

class _$TryToStartTrainCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res>
    implements $TryToStartTrainCopyWith<$Res> {
  _$TryToStartTrainCopyWithImpl(
      TryToStartTrain _value, $Res Function(TryToStartTrain) _then)
      : super(_value, (v) => _then(v as TryToStartTrain));

  @override
  TryToStartTrain get _value => super._value as TryToStartTrain;
}

class _$TryToStartTrain implements TryToStartTrain {
  _$TryToStartTrain();

  @override
  String toString() {
    return 'LibraryEvent.tryToStartTrain()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TryToStartTrain);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return tryToStartTrain();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tryToStartTrain != null) {
      return tryToStartTrain();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return tryToStartTrain(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tryToStartTrain != null) {
      return tryToStartTrain(this);
    }
    return orElse();
  }
}

abstract class TryToStartTrain implements LibraryEvent {
  factory TryToStartTrain() = _$TryToStartTrain;
}

abstract class $AddDeckCopyWith<$Res> {
  factory $AddDeckCopyWith(AddDeck value, $Res Function(AddDeck) then) =
      _$AddDeckCopyWithImpl<$Res>;
  $Res call({Deck deck});
}

class _$AddDeckCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $AddDeckCopyWith<$Res> {
  _$AddDeckCopyWithImpl(AddDeck _value, $Res Function(AddDeck) _then)
      : super(_value, (v) => _then(v as AddDeck));

  @override
  AddDeck get _value => super._value as AddDeck;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(AddDeck(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }
}

class _$AddDeck implements AddDeck {
  _$AddDeck({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.addDeck(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddDeck &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $AddDeckCopyWith<AddDeck> get copyWith =>
      _$AddDeckCopyWithImpl<AddDeck>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return addDeck(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (addDeck != null) {
      return addDeck(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return addDeck(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (addDeck != null) {
      return addDeck(this);
    }
    return orElse();
  }
}

abstract class AddDeck implements LibraryEvent {
  factory AddDeck({@required Deck deck}) = _$AddDeck;

  Deck get deck;
  $AddDeckCopyWith<AddDeck> get copyWith;
}

abstract class $UpdateDeckCopyWith<$Res> {
  factory $UpdateDeckCopyWith(
          UpdateDeck value, $Res Function(UpdateDeck) then) =
      _$UpdateDeckCopyWithImpl<$Res>;
  $Res call({Deck deck});
}

class _$UpdateDeckCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $UpdateDeckCopyWith<$Res> {
  _$UpdateDeckCopyWithImpl(UpdateDeck _value, $Res Function(UpdateDeck) _then)
      : super(_value, (v) => _then(v as UpdateDeck));

  @override
  UpdateDeck get _value => super._value as UpdateDeck;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(UpdateDeck(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }
}

class _$UpdateDeck implements UpdateDeck {
  _$UpdateDeck({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.updateDeck(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UpdateDeck &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $UpdateDeckCopyWith<UpdateDeck> get copyWith =>
      _$UpdateDeckCopyWithImpl<UpdateDeck>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return updateDeck(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateDeck != null) {
      return updateDeck(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return updateDeck(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateDeck != null) {
      return updateDeck(this);
    }
    return orElse();
  }
}

abstract class UpdateDeck implements LibraryEvent {
  factory UpdateDeck({@required Deck deck}) = _$UpdateDeck;

  Deck get deck;
  $UpdateDeckCopyWith<UpdateDeck> get copyWith;
}

abstract class $DeleteDeckCopyWith<$Res> {
  factory $DeleteDeckCopyWith(
          DeleteDeck value, $Res Function(DeleteDeck) then) =
      _$DeleteDeckCopyWithImpl<$Res>;
  $Res call({Deck deck});
}

class _$DeleteDeckCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $DeleteDeckCopyWith<$Res> {
  _$DeleteDeckCopyWithImpl(DeleteDeck _value, $Res Function(DeleteDeck) _then)
      : super(_value, (v) => _then(v as DeleteDeck));

  @override
  DeleteDeck get _value => super._value as DeleteDeck;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(DeleteDeck(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }
}

class _$DeleteDeck implements DeleteDeck {
  _$DeleteDeck({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.deleteDeck(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DeleteDeck &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $DeleteDeckCopyWith<DeleteDeck> get copyWith =>
      _$DeleteDeckCopyWithImpl<DeleteDeck>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return deleteDeck(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (deleteDeck != null) {
      return deleteDeck(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return deleteDeck(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (deleteDeck != null) {
      return deleteDeck(this);
    }
    return orElse();
  }
}

abstract class DeleteDeck implements LibraryEvent {
  factory DeleteDeck({@required Deck deck}) = _$DeleteDeck;

  Deck get deck;
  $DeleteDeckCopyWith<DeleteDeck> get copyWith;
}

abstract class $TrainStartedCopyWith<$Res> {
  factory $TrainStartedCopyWith(
          TrainStarted value, $Res Function(TrainStarted) then) =
      _$TrainStartedCopyWithImpl<$Res>;
}

class _$TrainStartedCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $TrainStartedCopyWith<$Res> {
  _$TrainStartedCopyWithImpl(
      TrainStarted _value, $Res Function(TrainStarted) _then)
      : super(_value, (v) => _then(v as TrainStarted));

  @override
  TrainStarted get _value => super._value as TrainStarted;
}

class _$TrainStarted implements TrainStarted {
  _$TrainStarted();

  @override
  String toString() {
    return 'LibraryEvent.trainStarted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TrainStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return trainStarted();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (trainStarted != null) {
      return trainStarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    return trainStarted(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (trainStarted != null) {
      return trainStarted(this);
    }
    return orElse();
  }
}

abstract class TrainStarted implements LibraryEvent {
  factory TrainStarted() = _$TrainStarted;
}
