// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'library_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$LibraryEventTearOff {
  const _$LibraryEventTearOff();

  GetAllUsersDecks getAllUsersDecks() {
    return GetAllUsersDecks();
  }

  TryToStartTrain tryToStartTrain() {
    return TryToStartTrain();
  }

  AddDeck addDeck({@required Deck deck}) {
    return AddDeck(
      deck: deck,
    );
  }

  UpdateDeck updateDeck({@required Deck deck}) {
    return UpdateDeck(
      deck: deck,
    );
  }

  DeleteDeck deleteDeck({@required Deck deck}) {
    return DeleteDeck(
      deck: deck,
    );
  }

  TrainStarted trainStarted() {
    return TrainStarted();
  }

  UndoAdding undoAdding({@required Deck deck}) {
    return UndoAdding(
      deck: deck,
    );
  }

  UndoDeleting undoDeleting({@required Deck deck}) {
    return UndoDeleting(
      deck: deck,
    );
  }

  UndoEditing undoEditing({@required Deck oldDeck}) {
    return UndoEditing(
      oldDeck: oldDeck,
    );
  }
}

// ignore: unused_element
const $LibraryEvent = _$LibraryEventTearOff();

mixin _$LibraryEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  });
}

abstract class $LibraryEventCopyWith<$Res> {
  factory $LibraryEventCopyWith(
          LibraryEvent value, $Res Function(LibraryEvent) then) =
      _$LibraryEventCopyWithImpl<$Res>;
}

class _$LibraryEventCopyWithImpl<$Res> implements $LibraryEventCopyWith<$Res> {
  _$LibraryEventCopyWithImpl(this._value, this._then);

  final LibraryEvent _value;
  // ignore: unused_field
  final $Res Function(LibraryEvent) _then;
}

abstract class $GetAllUsersDecksCopyWith<$Res> {
  factory $GetAllUsersDecksCopyWith(
          GetAllUsersDecks value, $Res Function(GetAllUsersDecks) then) =
      _$GetAllUsersDecksCopyWithImpl<$Res>;
}

class _$GetAllUsersDecksCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res>
    implements $GetAllUsersDecksCopyWith<$Res> {
  _$GetAllUsersDecksCopyWithImpl(
      GetAllUsersDecks _value, $Res Function(GetAllUsersDecks) _then)
      : super(_value, (v) => _then(v as GetAllUsersDecks));

  @override
  GetAllUsersDecks get _value => super._value as GetAllUsersDecks;
}

class _$GetAllUsersDecks implements GetAllUsersDecks {
  _$GetAllUsersDecks();

  @override
  String toString() {
    return 'LibraryEvent.getAllUsersDecks()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is GetAllUsersDecks);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return getAllUsersDecks();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getAllUsersDecks != null) {
      return getAllUsersDecks();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return getAllUsersDecks(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getAllUsersDecks != null) {
      return getAllUsersDecks(this);
    }
    return orElse();
  }
}

abstract class GetAllUsersDecks implements LibraryEvent {
  factory GetAllUsersDecks() = _$GetAllUsersDecks;
}

abstract class $TryToStartTrainCopyWith<$Res> {
  factory $TryToStartTrainCopyWith(
          TryToStartTrain value, $Res Function(TryToStartTrain) then) =
      _$TryToStartTrainCopyWithImpl<$Res>;
}

class _$TryToStartTrainCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res>
    implements $TryToStartTrainCopyWith<$Res> {
  _$TryToStartTrainCopyWithImpl(
      TryToStartTrain _value, $Res Function(TryToStartTrain) _then)
      : super(_value, (v) => _then(v as TryToStartTrain));

  @override
  TryToStartTrain get _value => super._value as TryToStartTrain;
}

class _$TryToStartTrain implements TryToStartTrain {
  _$TryToStartTrain();

  @override
  String toString() {
    return 'LibraryEvent.tryToStartTrain()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TryToStartTrain);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return tryToStartTrain();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tryToStartTrain != null) {
      return tryToStartTrain();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return tryToStartTrain(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tryToStartTrain != null) {
      return tryToStartTrain(this);
    }
    return orElse();
  }
}

abstract class TryToStartTrain implements LibraryEvent {
  factory TryToStartTrain() = _$TryToStartTrain;
}

abstract class $AddDeckCopyWith<$Res> {
  factory $AddDeckCopyWith(AddDeck value, $Res Function(AddDeck) then) =
      _$AddDeckCopyWithImpl<$Res>;
  $Res call({Deck deck});

  $DeckCopyWith<$Res> get deck;
}

class _$AddDeckCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $AddDeckCopyWith<$Res> {
  _$AddDeckCopyWithImpl(AddDeck _value, $Res Function(AddDeck) _then)
      : super(_value, (v) => _then(v as AddDeck));

  @override
  AddDeck get _value => super._value as AddDeck;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(AddDeck(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }

  @override
  $DeckCopyWith<$Res> get deck {
    if (_value.deck == null) {
      return null;
    }
    return $DeckCopyWith<$Res>(_value.deck, (value) {
      return _then(_value.copyWith(deck: value));
    });
  }
}

class _$AddDeck implements AddDeck {
  _$AddDeck({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.addDeck(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddDeck &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $AddDeckCopyWith<AddDeck> get copyWith =>
      _$AddDeckCopyWithImpl<AddDeck>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return addDeck(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (addDeck != null) {
      return addDeck(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return addDeck(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (addDeck != null) {
      return addDeck(this);
    }
    return orElse();
  }
}

abstract class AddDeck implements LibraryEvent {
  factory AddDeck({@required Deck deck}) = _$AddDeck;

  Deck get deck;
  $AddDeckCopyWith<AddDeck> get copyWith;
}

abstract class $UpdateDeckCopyWith<$Res> {
  factory $UpdateDeckCopyWith(
          UpdateDeck value, $Res Function(UpdateDeck) then) =
      _$UpdateDeckCopyWithImpl<$Res>;
  $Res call({Deck deck});

  $DeckCopyWith<$Res> get deck;
}

class _$UpdateDeckCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $UpdateDeckCopyWith<$Res> {
  _$UpdateDeckCopyWithImpl(UpdateDeck _value, $Res Function(UpdateDeck) _then)
      : super(_value, (v) => _then(v as UpdateDeck));

  @override
  UpdateDeck get _value => super._value as UpdateDeck;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(UpdateDeck(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }

  @override
  $DeckCopyWith<$Res> get deck {
    if (_value.deck == null) {
      return null;
    }
    return $DeckCopyWith<$Res>(_value.deck, (value) {
      return _then(_value.copyWith(deck: value));
    });
  }
}

class _$UpdateDeck implements UpdateDeck {
  _$UpdateDeck({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.updateDeck(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UpdateDeck &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $UpdateDeckCopyWith<UpdateDeck> get copyWith =>
      _$UpdateDeckCopyWithImpl<UpdateDeck>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return updateDeck(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateDeck != null) {
      return updateDeck(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return updateDeck(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (updateDeck != null) {
      return updateDeck(this);
    }
    return orElse();
  }
}

abstract class UpdateDeck implements LibraryEvent {
  factory UpdateDeck({@required Deck deck}) = _$UpdateDeck;

  Deck get deck;
  $UpdateDeckCopyWith<UpdateDeck> get copyWith;
}

abstract class $DeleteDeckCopyWith<$Res> {
  factory $DeleteDeckCopyWith(
          DeleteDeck value, $Res Function(DeleteDeck) then) =
      _$DeleteDeckCopyWithImpl<$Res>;
  $Res call({Deck deck});

  $DeckCopyWith<$Res> get deck;
}

class _$DeleteDeckCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $DeleteDeckCopyWith<$Res> {
  _$DeleteDeckCopyWithImpl(DeleteDeck _value, $Res Function(DeleteDeck) _then)
      : super(_value, (v) => _then(v as DeleteDeck));

  @override
  DeleteDeck get _value => super._value as DeleteDeck;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(DeleteDeck(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }

  @override
  $DeckCopyWith<$Res> get deck {
    if (_value.deck == null) {
      return null;
    }
    return $DeckCopyWith<$Res>(_value.deck, (value) {
      return _then(_value.copyWith(deck: value));
    });
  }
}

class _$DeleteDeck implements DeleteDeck {
  _$DeleteDeck({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.deleteDeck(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DeleteDeck &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $DeleteDeckCopyWith<DeleteDeck> get copyWith =>
      _$DeleteDeckCopyWithImpl<DeleteDeck>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return deleteDeck(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (deleteDeck != null) {
      return deleteDeck(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return deleteDeck(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (deleteDeck != null) {
      return deleteDeck(this);
    }
    return orElse();
  }
}

abstract class DeleteDeck implements LibraryEvent {
  factory DeleteDeck({@required Deck deck}) = _$DeleteDeck;

  Deck get deck;
  $DeleteDeckCopyWith<DeleteDeck> get copyWith;
}

abstract class $TrainStartedCopyWith<$Res> {
  factory $TrainStartedCopyWith(
          TrainStarted value, $Res Function(TrainStarted) then) =
      _$TrainStartedCopyWithImpl<$Res>;
}

class _$TrainStartedCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $TrainStartedCopyWith<$Res> {
  _$TrainStartedCopyWithImpl(
      TrainStarted _value, $Res Function(TrainStarted) _then)
      : super(_value, (v) => _then(v as TrainStarted));

  @override
  TrainStarted get _value => super._value as TrainStarted;
}

class _$TrainStarted implements TrainStarted {
  _$TrainStarted();

  @override
  String toString() {
    return 'LibraryEvent.trainStarted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TrainStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return trainStarted();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (trainStarted != null) {
      return trainStarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return trainStarted(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (trainStarted != null) {
      return trainStarted(this);
    }
    return orElse();
  }
}

abstract class TrainStarted implements LibraryEvent {
  factory TrainStarted() = _$TrainStarted;
}

abstract class $UndoAddingCopyWith<$Res> {
  factory $UndoAddingCopyWith(
          UndoAdding value, $Res Function(UndoAdding) then) =
      _$UndoAddingCopyWithImpl<$Res>;
  $Res call({Deck deck});

  $DeckCopyWith<$Res> get deck;
}

class _$UndoAddingCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $UndoAddingCopyWith<$Res> {
  _$UndoAddingCopyWithImpl(UndoAdding _value, $Res Function(UndoAdding) _then)
      : super(_value, (v) => _then(v as UndoAdding));

  @override
  UndoAdding get _value => super._value as UndoAdding;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(UndoAdding(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }

  @override
  $DeckCopyWith<$Res> get deck {
    if (_value.deck == null) {
      return null;
    }
    return $DeckCopyWith<$Res>(_value.deck, (value) {
      return _then(_value.copyWith(deck: value));
    });
  }
}

class _$UndoAdding implements UndoAdding {
  _$UndoAdding({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.undoAdding(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UndoAdding &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $UndoAddingCopyWith<UndoAdding> get copyWith =>
      _$UndoAddingCopyWithImpl<UndoAdding>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return undoAdding(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (undoAdding != null) {
      return undoAdding(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return undoAdding(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (undoAdding != null) {
      return undoAdding(this);
    }
    return orElse();
  }
}

abstract class UndoAdding implements LibraryEvent {
  factory UndoAdding({@required Deck deck}) = _$UndoAdding;

  Deck get deck;
  $UndoAddingCopyWith<UndoAdding> get copyWith;
}

abstract class $UndoDeletingCopyWith<$Res> {
  factory $UndoDeletingCopyWith(
          UndoDeleting value, $Res Function(UndoDeleting) then) =
      _$UndoDeletingCopyWithImpl<$Res>;
  $Res call({Deck deck});

  $DeckCopyWith<$Res> get deck;
}

class _$UndoDeletingCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $UndoDeletingCopyWith<$Res> {
  _$UndoDeletingCopyWithImpl(
      UndoDeleting _value, $Res Function(UndoDeleting) _then)
      : super(_value, (v) => _then(v as UndoDeleting));

  @override
  UndoDeleting get _value => super._value as UndoDeleting;

  @override
  $Res call({
    Object deck = freezed,
  }) {
    return _then(UndoDeleting(
      deck: deck == freezed ? _value.deck : deck as Deck,
    ));
  }

  @override
  $DeckCopyWith<$Res> get deck {
    if (_value.deck == null) {
      return null;
    }
    return $DeckCopyWith<$Res>(_value.deck, (value) {
      return _then(_value.copyWith(deck: value));
    });
  }
}

class _$UndoDeleting implements UndoDeleting {
  _$UndoDeleting({@required this.deck}) : assert(deck != null);

  @override
  final Deck deck;

  @override
  String toString() {
    return 'LibraryEvent.undoDeleting(deck: $deck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UndoDeleting &&
            (identical(other.deck, deck) ||
                const DeepCollectionEquality().equals(other.deck, deck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(deck);

  @override
  $UndoDeletingCopyWith<UndoDeleting> get copyWith =>
      _$UndoDeletingCopyWithImpl<UndoDeleting>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return undoDeleting(deck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (undoDeleting != null) {
      return undoDeleting(deck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return undoDeleting(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (undoDeleting != null) {
      return undoDeleting(this);
    }
    return orElse();
  }
}

abstract class UndoDeleting implements LibraryEvent {
  factory UndoDeleting({@required Deck deck}) = _$UndoDeleting;

  Deck get deck;
  $UndoDeletingCopyWith<UndoDeleting> get copyWith;
}

abstract class $UndoEditingCopyWith<$Res> {
  factory $UndoEditingCopyWith(
          UndoEditing value, $Res Function(UndoEditing) then) =
      _$UndoEditingCopyWithImpl<$Res>;
  $Res call({Deck oldDeck});

  $DeckCopyWith<$Res> get oldDeck;
}

class _$UndoEditingCopyWithImpl<$Res> extends _$LibraryEventCopyWithImpl<$Res>
    implements $UndoEditingCopyWith<$Res> {
  _$UndoEditingCopyWithImpl(
      UndoEditing _value, $Res Function(UndoEditing) _then)
      : super(_value, (v) => _then(v as UndoEditing));

  @override
  UndoEditing get _value => super._value as UndoEditing;

  @override
  $Res call({
    Object oldDeck = freezed,
  }) {
    return _then(UndoEditing(
      oldDeck: oldDeck == freezed ? _value.oldDeck : oldDeck as Deck,
    ));
  }

  @override
  $DeckCopyWith<$Res> get oldDeck {
    if (_value.oldDeck == null) {
      return null;
    }
    return $DeckCopyWith<$Res>(_value.oldDeck, (value) {
      return _then(_value.copyWith(oldDeck: value));
    });
  }
}

class _$UndoEditing implements UndoEditing {
  _$UndoEditing({@required this.oldDeck}) : assert(oldDeck != null);

  @override
  final Deck oldDeck;

  @override
  String toString() {
    return 'LibraryEvent.undoEditing(oldDeck: $oldDeck)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UndoEditing &&
            (identical(other.oldDeck, oldDeck) ||
                const DeepCollectionEquality().equals(other.oldDeck, oldDeck)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(oldDeck);

  @override
  $UndoEditingCopyWith<UndoEditing> get copyWith =>
      _$UndoEditingCopyWithImpl<UndoEditing>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getAllUsersDecks(),
    @required Result tryToStartTrain(),
    @required Result addDeck(Deck deck),
    @required Result updateDeck(Deck deck),
    @required Result deleteDeck(Deck deck),
    @required Result trainStarted(),
    @required Result undoAdding(Deck deck),
    @required Result undoDeleting(Deck deck),
    @required Result undoEditing(Deck oldDeck),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return undoEditing(oldDeck);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getAllUsersDecks(),
    Result tryToStartTrain(),
    Result addDeck(Deck deck),
    Result updateDeck(Deck deck),
    Result deleteDeck(Deck deck),
    Result trainStarted(),
    Result undoAdding(Deck deck),
    Result undoDeleting(Deck deck),
    Result undoEditing(Deck oldDeck),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (undoEditing != null) {
      return undoEditing(oldDeck);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getAllUsersDecks(GetAllUsersDecks value),
    @required Result tryToStartTrain(TryToStartTrain value),
    @required Result addDeck(AddDeck value),
    @required Result updateDeck(UpdateDeck value),
    @required Result deleteDeck(DeleteDeck value),
    @required Result trainStarted(TrainStarted value),
    @required Result undoAdding(UndoAdding value),
    @required Result undoDeleting(UndoDeleting value),
    @required Result undoEditing(UndoEditing value),
  }) {
    assert(getAllUsersDecks != null);
    assert(tryToStartTrain != null);
    assert(addDeck != null);
    assert(updateDeck != null);
    assert(deleteDeck != null);
    assert(trainStarted != null);
    assert(undoAdding != null);
    assert(undoDeleting != null);
    assert(undoEditing != null);
    return undoEditing(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getAllUsersDecks(GetAllUsersDecks value),
    Result tryToStartTrain(TryToStartTrain value),
    Result addDeck(AddDeck value),
    Result updateDeck(UpdateDeck value),
    Result deleteDeck(DeleteDeck value),
    Result trainStarted(TrainStarted value),
    Result undoAdding(UndoAdding value),
    Result undoDeleting(UndoDeleting value),
    Result undoEditing(UndoEditing value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (undoEditing != null) {
      return undoEditing(this);
    }
    return orElse();
  }
}

abstract class UndoEditing implements LibraryEvent {
  factory UndoEditing({@required Deck oldDeck}) = _$UndoEditing;

  Deck get oldDeck;
  $UndoEditingCopyWith<UndoEditing> get copyWith;
}
